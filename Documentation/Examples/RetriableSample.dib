#!markdown

# Corvus.Retry.Retriable - Sample Notebook

#!markdown

First, add a reference to the `Corvus.Retry` NuGet package.

#!csharp

#r "nuget: Corvus.Retry, 1.0.2"

#!markdown

Add using statement for `Corvus.Retry` namespace

#!csharp

using Corvus.Retry;
using Corvus.Retry.Strategies;
using Corvus.Retry.Policies;
using System.Net.NetworkInformation;
using System.Threading;
using System.Net.Http;
using System.Web;

#!markdown

`Retriable` is the most common usage pattern from the Corvus.Retry library. It wraps an existing method and allows you to re-execute the method if it throws an exception.

```csharp
Retriable.Retry(() => DoSomethingThatMightFail());
```

#!markdown

### `Retriable.Retry` – basic example

The following example uses `Retry` to wrap a method that pings an internet host.

#!csharp

Ping pingSender = new Ping();
Retriable.Retry(() => pingSender.Send("www.endjin.com"));

#!markdown

You can also return the values from the method. The following example uses the `PingReply` object returned by `Ping.Send()`:

#!csharp

Ping pingSender = new Ping();
PingReply reply = Retriable.Retry(() => pingSender.Send("www.endjin.com"));

// Print a property from the response
Console.WriteLine($"Address:\t{reply.Address.ToString()}");

#!markdown

### `Retriable.RetryAsync` – basic example

The `RetryAsync` method allows you to wrap an asynchronous method to re-execute it.

#!markdown

The following example uses `Retriable` to wrap an asynchronous method that sends a ping to a internet host and receives a response.

#!csharp

Ping pingSender = new Ping();
PingReply reply = await Retriable.RetryAsync(() => pingSender.SendPingAsync("www.endjin.com"));

// Print a property from the response
Console.WriteLine($"Address:\t{reply.Address.ToString()}");

#!markdown

## Cancellation token

You can pass a cancellation token to `Retry` to signal cancellation of the retry process.

### Using a cancellation token - examples

The default behavior of `Retry` is to not use a cancellation token: `CancellationToken.None`.

#!csharp

Ping pingSender = new Ping();
Retriable.Retry(() => pingSender.Send("www.endjin.com"), CancellationToken.None);

#!markdown

## Policy and Strategy

Two types help you to control when a failed operation is retried, and how that retry occurs. `IRetryPolicy` and `IRetryStrategy`. You can pass these policies as arguments to the parameters `strategy` and `policy` on the `Retry` and `RetryAsync` methods.

#!markdown

### `IRetryPolicy`

The retry policy gives you the ability to determine whether the operation should be retried or not, based on the exception that has been thrown.

This typically means you can distinguish between terminal exceptions (like bad input) and transient exceptions (like a network timeout).

There are three built-in retry policies:

#### `AnyException`
   
This will always retry on any exception, and is the default for `Retriable`.

#!csharp

Ping pingSender = new Ping();
PingReply reply = Retriable.Retry(() => pingSender.Send("www.endjin.com"), CancellationToken.None, strategy: new Count(10), policy: new AnyExceptionPolicy());

#!markdown

**Note**: the argument to the `strategy` parameter in the example above is specifying that the function should be retried a maximum of 10 times. `IRetryStrategy` is covered [later in the notebook](#iretrystrategy).

#!markdown

#### `DoNotRetryPolicy`

This will never retry, regardless of the exception. You use this to disable retry, without having to comment out your retry code.

Typically, you would do this with some kind of conditional:

#!csharp

bool isDebuggingOrWhatever = true;

IRetryPolicy policy = isDebuggingOrWhatever ? new DoNotRetryPolicy() : new AnyExceptionPolicy();

Ping pingSender = new Ping();
PingReply reply = Retriable.Retry(() => pingSender.Send("www.endjin.com"), CancellationToken.None, strategy: new Count(10), policy: policy);

#!markdown

####  Implementing a custom policy

To create your own custom policy implement the `IRetryPolicy` interface, and its `bool CanRetry(Exception exception)` method which allows you to define the behavior for determining whether to retry based on the exception that was raised.

##### Example - basic

Continuing with the `Ping.Send()` method, we can define a policy that will retry when a `PingException` exception is detected.

#!csharp

public class RetryOnPingExceptionPolicy : IRetryPolicy
{
  public bool CanRetry(Exception exception)
  {
    return (exception is PingException httpException);
  }
}

#!csharp

Ping pingSender = new Ping();
PingReply reply = Retriable.Retry(() => pingSender.Send("www.endjin.com"), CancellationToken.None, strategy: new Count(10), policy: new RetryOnPingExceptionPolicy());

#!markdown

##### Example - mock http service 

Let's imagine we were consuming an HttpService which occasionally gives us a `429 - Too Many Requests` error in an `HttpServiceException`.

We can implement a policy which will only retry if we receive this exception.

#!markdown

Let's first create a mock http service: `MockHttpService` and a mock http service exception: `MockHttpServiceException`.

`MockHttpService` has a single method, `MakeLotsOfRequest`, that always throws a `MockHttpServiceException` with a status code of `"429"`; the method also writes "method called" to the console so that we can see the number of times it is called later.

#!csharp

public class MockHttpService
{
    public void MakeLotsOfRequests()
    {
        Console.WriteLine("MakeLotsOfRequests() method called");
        throw new MockHttpServiceException("429 - Too Many Requests", "429");
    }
}

#!csharp

[Serializable]
public class MockHttpServiceException: Exception
{

    override public string Message { get; }
    public string StatusCode { get; }

    public MockHttpServiceException(string message, string statusCode)
    {
        this.Message = message;
        this.StatusCode = statusCode;
    }
}

#!markdown

Now, implement a custom policy that that will only retry when a `MockHttpServiceException` exception type is detected and the status code is `"429"`.

#!csharp

public class RetryOnTooManyRequestsPolicy : IRetryPolicy
{
  public bool CanRetry(Exception exception)
  {
    return (exception is MockHttpServiceException httpException && httpException.StatusCode == "429");
  }
}

#!markdown

Now, create an instance of `MockHttpService`, and call its `MakeLotsOfRequests` method - wrapping it with `Retriable.Retry` and passing it our `RetryOnTooManyRequestsPolicy` policy.

For the strategy I'm passing in `new Count(10)`, which means the method will be retried at most 10 times. Therefore we should expect to see "Method called" printed to the console 10 times.

#!csharp

MockHttpService mockHttpService = new();
Retriable.Retry(() => mockHttpService.MakeLotsOfRequests(), CancellationToken.None, strategy: new Count(10), policy: new RetryOnTooManyRequestsPolicy());

#!markdown

#### `AggrregatePolicy`

This gives you a means of combining together multiple policies.

The `AggregatePolicy` only succeeds if *ALL* of its children succeed.

An aggregate following takes the following form:

```csharp
var aggregatePolicy =
  new AggregatePolicy
  {
    Policies =
    {
      new CustomPolicy1(),
      new CustomPolicy2(),
    },
  }
```

##### Example - mock http service

Continuing with the mock http service example from earlier, let's say, in addition to retrying on detecting a "429 - too many requests" exception, you would also like to retry upon detecting a "408 - request timed out" exception.

#!markdown

First let's create another custom policy that will retry when a "408 - request timed out" exception is detected.

#!csharp

public class RetryOnRequestTimeoutPolicy: IRetryPolicy
{
    public bool CanRetry(Exception exception)
    {
        return (exception is MockHttpServiceException httpException && httpException.StatusCode == "408");
    }
}

#!markdown

Now, define an aggregate policy that combines `RetryOnRequestTimeoutPolicy` & `RetryOnTooManyRequestsPolicy`

#!csharp

AggregatePolicy aggregatePolicy = new AggregatePolicy()
{
    Policies = 
    {
        new RetryOnTooManyRequestsPolicy(),
        new RetryOnRequestTimeoutPolicy(),
    }
};

#!markdown

We need to update the `MockHttpService` class to contain a method that will throw a `MockHttpServiceException` exception type with a `"408"` status code: `MakeRequestThatWillTimeOut()`

Let's also add a `MakeRandomRequest()` method that will randomly call either `MakeRequestThatWillTimeOut` or `MakeLotsOfRequests()`, so that we can see the aggregate policy triggering on both exceptions.

#!csharp

public class MockHttpService
{
    private Random rand;

    public MockHttpService()
    {
        this.rand = new Random();
    }

    public void MakeLotsOfRequests()
    {
        Console.WriteLine("MakeLotsOfRequests() method called");
        throw new MockHttpServiceException("429 - Too Many Requests", "429");
    }

    public void MakeRequestThatWillTimeOut()
    {
        Console.WriteLine("MakeRequestThatWillTimeOut() method called");
        throw new MockHttpServiceException("408 - Request timed out", "408");
    }

    public void MakeRandomRequests()
    {
        // Randomly generate 0 or 1
        int randomNumber = rand.Next(0, 2);
        if (randomNumber == 0) {this.MakeLotsOfRequests();}
        else {this.MakeRequestThatWillTimeOut();}
        
    }
}

#!csharp

MockHttpService mockHttpService = new();
Retriable.Retry(() => mockHttpService.MakeRandomRequests(), CancellationToken.None, strategy: new Count(10), policy: aggregatePolicy);
