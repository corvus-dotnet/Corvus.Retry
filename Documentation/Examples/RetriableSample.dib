#!markdown

# Corvus.Retry.Retriable - Sample Notebook

#!markdown

First, add a reference to the `Corvus.Retry` NuGet package.

#!csharp

#r "nuget: Corvus.Retry, 1.0.2"

#!markdown

Add a using statement for `Corvus.Retry` namespace and the other we'll be using this notebook.

#!csharp

using Corvus.Retry;
using Corvus.Retry.Strategies;
using Corvus.Retry.Policies;
using System.Net.NetworkInformation;
using System.Threading;
using System.Net.Http;
using System.Web;
using System.Diagnostics;
using System.Threading;

#!markdown

`Retriable` is the most common usage pattern from the Corvus.Retry library. It wraps an existing method and allows you to re-execute the method if it throws an exception.

```csharp
Retriable.Retry(() => DoSomethingThatMightFail());
```

#!markdown

### `Retriable.Retry` – basic example

The following example uses `Retry` to wrap a method that pings an internet host.

#!csharp

Ping pingSender = new Ping();
Retriable.Retry(() => pingSender.Send("www.endjin.com"));

#!markdown

You can also return the values from the method. The following example uses the `PingReply` object returned by `Ping.Send()`:

#!csharp

Ping pingSender = new Ping();
PingReply reply = Retriable.Retry(() => pingSender.Send("www.endjin.com"));

// Print a property from the response
Console.WriteLine($"Address:\t{reply.Address.ToString()}");

#!markdown

### `Retriable.RetryAsync` – basic example

The `RetryAsync` method allows you to wrap an asynchronous method to re-execute it.

#!markdown

The following example uses `Retriable` to wrap an asynchronous method that sends a ping to a internet host and receives a response.

#!csharp

Ping pingSender = new Ping();
PingReply reply = await Retriable.RetryAsync(() => pingSender.SendPingAsync("www.endjin.com"));

// Print a property from the response
Console.WriteLine($"Address:\t{reply.Address.ToString()}");

#!markdown

## Cancellation token

You can pass a cancellation token to `Retry` to signal cancellation of the retry process.

### Using a cancellation token - examples

The default behavior of `Retry` is to not use a cancellation token: `CancellationToken.None`.

#!csharp

Ping pingSender = new Ping();
Retriable.Retry(() => pingSender.Send("www.endjin.com"), CancellationToken.None);

#!markdown

## Policy and Strategy

Two types help you to control when a failed operation is retried, and how that retry occurs. `IRetryPolicy` and `IRetryStrategy`. You can pass these policies as arguments to the parameters `strategy` and `policy` on the `Retry` and `RetryAsync` methods.

#!markdown

### `IRetryPolicy`

The retry policy gives you the ability to determine whether the operation should be retried or not, based on the exception that has been thrown.

This typically means you can distinguish between terminal exceptions (like bad input) and transient exceptions (like a network timeout).

There are three built-in retry policies:

#### `AnyException`
   
This will always retry on any exception, and is the default for `Retriable`.

#!csharp

Ping pingSender = new Ping();
PingReply reply = Retriable.Retry(() => pingSender.Send("www.endjin.com"), CancellationToken.None, strategy: new Count(10), policy: new AnyExceptionPolicy());

#!markdown

**Note**: the argument to the `strategy` parameter in the example above is specifying that the function should be retried a maximum of 10 times. `IRetryStrategy` is covered [later in the notebook](#iretrystrategy).

#!markdown

#### `DoNotRetryPolicy`

This will never retry, regardless of the exception. You use this to disable retry, without having to comment out your retry code.

Typically, you would do this with some kind of conditional:

#!csharp

bool isDebuggingOrWhatever = true;

IRetryPolicy policy = isDebuggingOrWhatever ? new DoNotRetryPolicy() : new AnyExceptionPolicy();

Ping pingSender = new Ping();
PingReply reply = Retriable.Retry(() => pingSender.Send("www.endjin.com"), CancellationToken.None, strategy: new Count(10), policy: policy);

#!markdown

####  Implementing a custom policy

To create your own custom policy implement the `IRetryPolicy` interface, and its `bool CanRetry(Exception exception)` method which allows you to define the behavior for determining whether to retry based on the exception that was raised.

##### Example - basic

Continuing with the `Ping.Send()` method, we can define a policy that will retry when a `PingException` exception is detected.

#!csharp

public class RetryOnPingExceptionPolicy : IRetryPolicy
{
  public bool CanRetry(Exception exception)
  {
    return (exception is PingException httpException);
  }
}

#!csharp

Ping pingSender = new Ping();
PingReply reply = Retriable.Retry(() => pingSender.Send("www.endjin.com"), CancellationToken.None, strategy: new Count(10), policy: new RetryOnPingExceptionPolicy());

#!markdown

##### Example - mock http service 

Let's imagine we were consuming an HttpService which occasionally gives us a `429 - Too Many Requests` error in an `HttpServiceException`.

We can implement a policy which will only retry if we receive this exception.

Let's first create a mock http service: `MockHttpService` and a mock http service exception: `MockHttpServiceException`.

#!csharp

[Serializable]
public class MockHttpServiceException: Exception
{

    override public string Message { get; }
    public string StatusCode { get; }

    public MockHttpServiceException(string message, string statusCode)
    {
        this.Message = message;
        this.StatusCode = statusCode;
    }
}

#!csharp

public class MockHttpService
{
    public void MakeLotsOfRequests()
    {
        Console.WriteLine("MakeLotsOfRequests() method called");
        throw new MockHttpServiceException("429 - Too Many Requests", "429");
    }
}

#!markdown

`MockHttpService` has a single method, `MakeLotsOfRequest`, that always throws a `MockHttpServiceException` with a status code of `"429"`; the method also writes "MakeLotsOfRequests() method called" to the console so that we can see the number of times it is called later.

Now, implement a custom policy that that will only retry when a `MockHttpServiceException` exception type is detected and the status code is `"429"`.

#!csharp

public class RetryOnTooManyRequestsPolicy : IRetryPolicy
{
  public bool CanRetry(Exception exception)
  {
    return (exception is MockHttpServiceException httpException && httpException.StatusCode == "429");
  }
}

#!markdown

Now, create an instance of `MockHttpService`, and call its `MakeLotsOfRequests` method - wrapping it with `Retriable.Retry` and passing it our `RetryOnTooManyRequestsPolicy` policy.

For the strategy I'm passing in `new Count(10)`, which means the method will be retried at most 10 times. Therefore we should expect to see "Method called" printed to the console 10 times.

#!csharp

MockHttpService mockHttpService = new();
Retriable.Retry(() => mockHttpService.MakeLotsOfRequests(), CancellationToken.None, strategy: new Count(10), policy: new RetryOnTooManyRequestsPolicy());

#!markdown

#### `AggrregatePolicy`

This gives you a means of combining together multiple policies.

The `AggregatePolicy` only succeeds if *ALL* of its children succeed.

An aggregate following takes the following form:

```csharp
var aggregatePolicy =
  new AggregatePolicy
  {
    Policies =
    {
      new CustomPolicy1(),
      new CustomPolicy2(),
    },
  }
```

##### Example - mock http service

In this example we create a policy that checks configuration to see if retry is disabled. This could be some configuration to allow you to disable retry whilst the application is running in production.

First create a class containing configuration stating whether retry is disabled or not:

#!csharp

public class RetryConfiguration
{
    public bool isRetryDisabled { get; set; }
}

#!markdown

Now the custom policy which takes a `RetryConfiguration` to construct and uses its `isRetryDisabled` property to determine whether to retry or not.

#!csharp

public class RetryOnRetryEnabledPolicy : IRetryPolicy
{

  public RetryConfiguration retryConfiguration;
  
  public RetryOnRetryEnabledPolicy(RetryConfiguration retryConfiguration)
  {
      this.retryConfiguration = retryConfiguration;
  }

  public bool CanRetry(Exception exception)
  {
    return (!retryConfiguration.isRetryDisabled);
  }
}

#!markdown

Now, define an aggregate policy that combines `RetryOnRetryEnabledPolicy` & `RetryOnTooManyRequestsPolicy`

#!csharp

AggregatePolicy aggregatePolicy = new AggregatePolicy()
{
    Policies = 
    {
        new RetryOnTooManyRequestsPolicy(),
        new RetryOnRetryEnabledPolicy(new RetryConfiguration())
    }
};

#!markdown

Now, try this aggregate policy with the `MockHttpService.MakeLotsOfRequests()` method.

The default value of the `isRetryDisabled` property on `RetryConfiguration` is `false`, therefore the two conditions in `aggregatePolicy` will pass, and the method will be retried every time.

#!csharp

MockHttpService mockHttpService = new();
Retriable.Retry(() => mockHttpService.MakeLotsOfRequests(), CancellationToken.None, strategy: new Count(10), policy: aggregatePolicy);

#!markdown

If we make set  the `isRetryDisabled` property on `RetryConfiguration` to `false`, the condition in `RetryOnRetryEnabledPolicy` will not pass, and therefore `aggregatePolicy` will not trigger a retry.

#!csharp

var retryConfiguration = new RetryConfiguration();
var retryOnRetryEnabledPolicy = new RetryOnRetryEnabledPolicy(retryConfiguration);

AggregatePolicy aggregatePolicy = new AggregatePolicy()
{
    Policies = 
    {
        new RetryOnTooManyRequestsPolicy(),
        retryOnRetryEnabledPolicy
    }
};

// Change isRetryDisabled to true
retryConfiguration.isRetryDisabled = true;

MockHttpService mockHttpService = new();
Retriable.Retry(() => mockHttpService.MakeLotsOfRequests(), CancellationToken.None, strategy: new Count(10), policy: aggregatePolicy);

#!markdown

If something similar were running in production, there may be a config change that prevents retries *whilst* a retry run is happening. Let's simulate that by starting a retry run (using the `Linear` strategy such that the delay between each retry is 2 seconds) asynchronously, and change the `isRetryDisabled` config property whilst it's running.

#!csharp

var retryConfiguration = new RetryConfiguration();
var retryOnRetryEnabledPolicy = new RetryOnRetryEnabledPolicy(retryConfiguration);

AggregatePolicy aggregatePolicy = new AggregatePolicy()
{
    Policies = 
    {
        new RetryOnTooManyRequestsPolicy(),
        retryOnRetryEnabledPolicy
    }
};

// Change isRetryDisabled to true
//retryConfiguration.isRetryDisabled = true;

MockHttpService mockHttpService = new();
Action retryAction = () => Retriable.Retry(() => mockHttpService.MakeLotsOfRequests(), CancellationToken.None, strategy: new Linear(TimeSpan.FromSeconds(2), 10), policy: aggregatePolicy);
Task retryTask = Task.Factory.StartNew(retryAction);
Thread.Sleep(5000);
retryConfiguration.isRetryDisabled = true;
retryTask.Wait();

#!markdown

#### Semi-obsolete example start 

--------------------------------------------------------------------------------------

#!markdown

First let's create another custom policy that will retry when a "408 - request timed out" exception is detected.

#!csharp

public class RetryOnRequestTimeoutPolicy: IRetryPolicy
{
    public bool CanRetry(Exception exception)
    {
        return (exception is MockHttpServiceException httpException && httpException.StatusCode == "408");
    }
}

#!markdown

We need to update the `MockHttpService` class to contain a method that will throw a `MockHttpServiceException` exception type with a `"408"` status code: `MakeRequestThatWillTimeOut()`

Let's also add a `MakeRandomRequest()` method that will randomly call either `MakeRequestThatWillTimeOut` or `MakeLotsOfRequests()`, so that we can see the aggregate policy triggering on both exceptions.

#!csharp

public class MockHttpService
{
    private Random rand;

    public MockHttpService()
    {
        this.rand = new Random();
    }

    public void MakeLotsOfRequests()
    {
        Console.WriteLine("MakeLotsOfRequests() method called");
        throw new MockHttpServiceException("429 - Too Many Requests", "429");
    }

    public void MakeRequestThatWillTimeOut()
    {
        Console.WriteLine("MakeRequestThatWillTimeOut() method called");
        throw new MockHttpServiceException("408 - Request timed out", "408");
    }

    public void MakeRandomRequests()
    {
        // Randomly generate 0 or 1
        int randomNumber = rand.Next(0, 2);
        if (randomNumber == 0) {this.MakeLotsOfRequests();}
        else {this.MakeRequestThatWillTimeOut();}
        
    }
}

#!markdown

Run the cell above and you will see *Submission#{number}+MockHttpService*. Now re-compile `MockHttpService` and re-run the cell above; you will see a different number. This is pointing to the fact that, in .NET interactive notebooks, each compilation of a type leads to a new type (indicated by the different submission number). This can lead to strange behavior, especially when matching against exceptions - if you try to match against an exception type defined in the notebook, and then re-compile the exception type, the type thrown by the method is going to be different to the one you're trying to match against.

You therefore need to make sure that you can do a *run all* in the notebook and have every cell in the right order so that it works properly, and that you don't have to go back and recompile things out of order.

#!csharp

Console.WriteLine(typeof(MockHttpService).FullName)

#!csharp

MockHttpService mockHttpService = new();
Retriable.Retry(() => mockHttpService.MakeRandomRequests(), CancellationToken.None, strategy: new Count(10), policy: aggregatePolicy);

#!markdown

#### Semi-obsolete example end

--------------------------------------------------------------------------------------------

#!markdown

### `IRetryStrategy`

The `IRetryStrategy` controls the way in which the operation is retried. It controls both the _delay between each retry_ and the _number of times that it will be retried_.

There are several strategies provided out-of-the-box: `Count`, `DoNotRetry`, `Linear`, `Incremental`, and `Backoff`.

#!markdown

#### `Count`

We've seen this retry strategy in the `IRetryPolicy` examples earlier.

This simply retries a specified number of times, with no delay. `Retriable` operations default to a `new Count(10)` strategy.

##### Example

Reusing the `MockHttpService` from earlier, if we call the `MakeLotsOfRequests()` method (which always throws a "429 - Too Many Requests" `MockHttpServiceException` exception type) and supply a `RetryWhenTooManyRequestsPolicy` for the policy, and supply `new Count(10)` for the strategy, we should expect to see the method call retried 10 times. 

#!csharp

MockHttpService mockHttpService = new();
Retriable.Retry(() => mockHttpService.MakeLotsOfRequests(), CancellationToken.None, strategy: new Count(10), policy: new RetryOnTooManyRequestsPolicy());

#!markdown

#### `DoNotRetry`
This is the strategy equivalent of the `DoNotRetryPolicy`. It forces a retry to be abandoned, regardless of policy.

##### Example

Using the same example as in the `Count` retry policy above, the method will be called once and not retried.

#!csharp

MockHttpService mockHttpService = new();
Retriable.Retry(() => mockHttpService.MakeLotsOfRequests(), CancellationToken.None, strategy: new DoNotRetry(), policy: new RetryOnTooManyRequestsPolicy());

#!markdown

#### `Linear`
This retries a specified number of times (specified by `maxTries`), with an constant delay between each retry (specified by `periodicity`).

For example, `new Linear(TimeSpan.FromSeconds(1), 5)` will retry up to 5 times. Each time it will  delay by 1s. So the first retry will be after 1s (wall clock time 1s), the second after another 1s (wall clock time 2s), the third after another 1s (wall clock time 3s).

#!csharp

MockHttpService mockHttpService = new();
Retriable.Retry(() => mockHttpService.MakeLotsOfRequests(), CancellationToken.None, strategy: new Linear(periodicity: TimeSpan.FromSeconds(1), maxTries: 5), policy: new RetryOnTooManyRequestsPolicy());

#!markdown

If we introduce a `Clock` object and add an overload for `MockHttpService.MakeLotsOfRequests()` that records the time elapsed between each retry, we can see the how the `Linear` retry policy retries over time.

#!csharp

public class Clock
{
    public int Count { get; private set; }
    public Stopwatch stopwatch { get; }
    
    public Clock()
    {
        Count = 0;
        stopwatch = new Stopwatch();
    }

    public void IncrementCounter()
    {
        this.Count += 1;
    }
}

#!csharp

public class MockHttpService
{
    private Random rand;

    public MockHttpService()
    {
        this.rand = new Random();
    }

    public void MakeLotsOfRequests()
    {
        Console.WriteLine("MakeLotsOfRequests() method called");
        throw new MockHttpServiceException("429 - Too Many Requests", "429");
    }

    public void MakeLotsOfRequests(Clock clock)
    {
        Console.WriteLine("MakeLotsOfRequests() method called");

        if (clock.Count != 0)
        {
            clock.stopwatch.Stop();
            TimeSpan timeElapsed = clock.stopwatch.Elapsed;
            Console.WriteLine($"Time elapsed: {timeElapsed.Seconds}");
        }

        clock.IncrementCounter();
        clock.stopwatch.Start();
        throw new MockHttpServiceException("429 - Too Many Requests", "429");
    }

    public void MakeRequestThatWillTimeOut()
    {
        Console.WriteLine("MakeRequestThatWillTimeOut() method called");
        throw new MockHttpServiceException("408 - Request timed out", "408");
    }

    public void MakeRandomRequests()
    {
        // Randomly generate 0 or 1
        int randomNumber = rand.Next(0, 2);
        if (randomNumber == 0) {this.MakeLotsOfRequests();}
        else {this.MakeRequestThatWillTimeOut();}
        
    }
}

#!csharp

MockHttpService mockHttpService = new();
Clock clock = new();
Retriable.Retry(() => mockHttpService.MakeLotsOfRequests(clock), CancellationToken.None, strategy: new Linear(periodicity: TimeSpan.FromSeconds(1), maxTries: 5), policy: new RetryOnTooManyRequestsPolicy());

#!markdown

#### `Incremental`
This retries a specified number of times, with an arithmetically increasing delay between each retry.

For example, `new(maxTries: 5, intialDelay: TimeSpan.FromSeconds(1), step: TimeSpan.FromSeconds(1))` will retry up to 5 times. The initial delay will be one second. Each time it will increase the delay by 1s. So the first retry will be after 1s (wall clock time 1s), the second after another 2s (wall clock time 3s), the third after another 3s (wall clock time 6s).

This allows a slowly increasing delay.

##### Example

Using the same example as with `Linear` above, we can see the how the `Incremental` policy retries over time.

#!csharp

MockHttpService mockHttpService = new();
Clock clock = new();
Incremental incrementalStrategy = new(maxTries: 5, intialDelay: TimeSpan.FromSeconds(1), step: TimeSpan.FromSeconds(1));
Retriable.Retry(() => mockHttpService.MakeLotsOfRequests(clock), CancellationToken.None, strategy: incrementalStrategy, policy: new RetryOnTooManyRequestsPolicy());

#!markdown

#### `Backoff`
This retries a specified number of times, with a delay that increases geometrically between each retry.

For example, `new Backoff(maxTries: 5, deltaBackoff: TimeSpan.FromSeconds(1))` will retry up to 5 times. Each time it will increase the delay by a value calculated roughly like this: `2^n * (delta +/- a small random fudge)`, where `n` is the current number of retries.

This allows a rapidly increasing delay, with a bit of random jitter addded to avoid contention.

You can also set a `MinBackoff` and `MaxBackoff` to limit the lower and upper bounds of the delay.

##### Example

#!csharp

MockHttpService mockHttpService = new();
Clock clock = new();
Backoff backoffStrategy = new(maxTries: 4, deltaBackoff: TimeSpan.FromSeconds(1));
Retriable.Retry(() => mockHttpService.MakeLotsOfRequests(clock), CancellationToken.None, strategy: backoffStrategy, policy: new RetryOnTooManyRequestsPolicy());

#!markdown

##### Example - using `MinBackoff` and `MaxBackoff`

`MinBackoff` and `MaxBackoff` are available as settable properties on a `BackOff` object. If we use the same example as above but set the `MaxBackoff` to 5 seconds, we will see that once the number of retries reaches a number such that  delay > 5 seconds, the delay between each retry will be restricted to 5 seconds.

#!csharp

MockHttpService mockHttpService = new();
Clock clock = new();
Backoff backoffStrategy = new(maxTries: 5, deltaBackoff: TimeSpan.FromSeconds(1));
backoffStrategy.MaxBackoff = TimeSpan.FromSeconds(5);
Retriable.Retry(() => mockHttpService.MakeLotsOfRequests(clock), CancellationToken.None, strategy: backoffStrategy, policy: new RetryOnTooManyRequestsPolicy());

#!markdown

And, if we set the `MinBackoff` to be 2 seconds (the default is 1 second), we will see the time elapsed between each retry increase by 1 second on average.

#!csharp

MockHttpService mockHttpService = new();
Clock clock = new();
Backoff backoffStrategy = new(maxTries: 4, deltaBackoff: TimeSpan.FromSeconds(1));
backoffStrategy.MinBackoff = TimeSpan.FromSeconds(2);
Retriable.Retry(() => mockHttpService.MakeLotsOfRequests(clock), CancellationToken.None, strategy: backoffStrategy, policy: new RetryOnTooManyRequestsPolicy());

#!markdown

#### Implementing a custom strategy

It is slightly more complex to implement a custom retry strategy than it was to implement a retry policy. Although you can directly implemet the `IRetryStrategy` interface, it is usually simpler to derive from the abstract `RetryStrategy` class.

In that case, you need to override the `TimeSpan PrepareToRetry(Exception lastException)` method. You can examine the exception and use your internal state to determine two things:

1) Should we record this exception, or filter it out? Typically, we will want to record the exception, and, if so, we call `this.AddException(lastException)`.
2) For how long should we delay before retrying? We return a `TimeSpan` from the method to determine this.

So, for example, `Count` implements the method like this:

```csharp
public override TimeSpan PrepareToRetry(Exception lastException)
{
  if (lastException is null)
  {
    throw new ArgumentNullException(nameof(lastException));
  }

  this.AddException(lastException);
  this.tryCount++;
  return TimeSpan.Zero;
}
```

It updates its internal state to keep a count of the number of retries, adds the exception to the list of exceptions we have seen, and tells the strategy not to delay before retrying.

We also override the `bool CanRetry { get; }` property to determine wether this strategy still allows us to retry.

The `Count` strategy, for example, simply uses its internal state to determine whether to continue.

##### Example

The following example defines a strategy that determines the delay by randomly selecting a number of seconds between user-provided upper and lower limits.

#!csharp

public class RandomDelay : RetryStrategy
    {
        private readonly int maxTries;
        private readonly int lowerLimit;
        private readonly int upperLimit;

        private int tryCount;

        public RandomDelay()
            : this(maxTries: 5, lowerLimit: 1, upperLimit: 5)
        {
        }

        public RandomDelay(int maxTries, int lowerLimit, int upperLimit)
        {
            if (maxTries <= 0)
            {
                throw new ArgumentException("Max tries must be > 0", nameof(maxTries));
            }

            this.maxTries = maxTries;
            this.lowerLimit = lowerLimit;
            this.upperLimit = upperLimit;
        }

        public override bool CanRetry
        {
            get
            {
                return this.tryCount < this.maxTries;
            }
        }

        public override TimeSpan PrepareToRetry(Exception lastException)
        {
            if (lastException is null)
            {
                throw new ArgumentNullException(nameof(lastException));
            }

            this.AddException(lastException);

            this.tryCount += 1;

            if (this.CanRetry)
            {
                var rand = new Random();
                TimeSpan delay = TimeSpan.FromSeconds(rand.Next(lowerLimit, upperLimit));
                return delay;
            }

            return TimeSpan.Zero;
        }
    }

#!markdown

Let's try it...

#!csharp

MockHttpService mockHttpService = new();
Clock clock = new();
RandomDelay randomDelayStrategy = new(maxTries: 4, lowerLimit: 1, upperLimit: 5);
Retriable.Retry(() => mockHttpService.MakeLotsOfRequests(clock), CancellationToken.None, strategy: randomDelayStrategy, policy: new RetryOnTooManyRequestsPolicy());
