#!markdown

# Corvus.Retry.Retriable - Sample Notebook

#!markdown

First, add a reference to the `Corvus.Retry` NuGet package.

#!csharp

#r "nuget: Corvus.Retry, 1.0.2"

#!markdown

Add using statement for `Corvus.Retry` namespace

#!csharp

using Corvus.Retry;
using Corvus.Retry.Strategies;
using Corvus.Retry.Policies;
using System.Net.NetworkInformation;
using System.Threading;
using System.Net.Http;

#!markdown

`Retriable` is the most common usage pattern from the Corvus.Retry library. It wraps an existing method and allows you to re-execute the method if it throws an exception.

```csharp
Retriable.Retry(() => DoSomethingThatMightFail());
```

#!markdown

### `Retriable.Retry` – basic example

The following example uses `Retry` to wrap a method that pings an internet host.

#!csharp

Ping pingSender = new Ping();
Retriable.Retry(() => pingSender.Send("www.endjin.com"));

#!markdown

You can also return the values from the method. The following example uses the `PingReply` object returned by `Ping.Send()`:

#!csharp

Ping pingSender = new Ping();
PingReply reply = Retriable.Retry(() => pingSender.Send("www.endjin.com"));

// Print a property from the response
Console.WriteLine($"Address:\t{reply.Address.ToString()}");

#!markdown

### `Retriable.RetryAsync` – basic example

The `RetryAsync` method allows you to wrap an asynchronous method to re-execute it.

#!markdown

The following example uses `Retriable` to wrap an asynchronous method that sends a ping to a internet host and receives a response.

#!csharp

Ping pingSender = new Ping();
PingReply reply = await Retriable.RetryAsync(() => pingSender.SendPingAsync("www.endjin.com"));

// Print a property from the response
Console.WriteLine($"Address:\t{reply.Address.ToString()}");

#!markdown

## Cancellation token

You can pass a cancellation token to `Retry` to signal cancellation of the retry process.

### Using a cancellation token - examples

The default behavior of `Retry` is to not use a cancellation token: `CancellationToken.None`.

#!csharp

Ping pingSender = new Ping();
Retriable.Retry(() => pingSender.Send("www.endjin.com"), CancellationToken.None);

#!markdown

## Policy and Strategy

Two types help you to control when a failed operation is retried, and how that retry occurs. `IRetryPolicy` and `IRetryStrategy`. You can pass these policies as arguments to the parameters `strategy` and `policy` on the `Retry` and `RetryAsync` methods.

#!markdown

### `IRetryPolicy`

The retry policy gives you the ability to determine whether the operation should be retried or not, based on the exception that has been thrown.

This typically means you can distinguish between terminal exceptions (like bad input) and transient exceptions (like a network timeout).

There are three built-in retry policies:

#### `AnyException`
   
This will always retry on any exception, and is the default for `Retriable`.

#!csharp

Ping pingSender = new Ping();
PingReply reply = Retriable.Retry(() => pingSender.Send("www.endjin.com"), CancellationToken.None, strategy: new Count(10), policy: new AnyExceptionPolicy());

#!markdown

**Note**: the argument to the `strategy` parameter in the example above is specifying that the function should be retried a maximum of 10 times. `IRetryStrategy` is covered [later in the notebook](#iretrystrategy).

#!markdown

#### `DoNotRetryPolicy`

This will never retry, regardless of the exception. You use this to disable retry, without having to comment out your retry code.

Typically, you would do this with some kind of conditional:

#!csharp

bool isDebuggingOrWhatever = true;

IRetryPolicy policy = isDebuggingOrWhatever ? new DoNotRetryPolicy() : new AnyExceptionPolicy();

Ping pingSender = new Ping();
PingReply reply = Retriable.Retry(() => pingSender.Send("www.endjin.com"), CancellationToken.None, strategy: new Count(10), policy: policy);

#!markdown

####  Implementing a custom policy

To create your own custom policy implement the `IRetryPolicy` interface, and its `bool CanRetry(Exception exception)` method which allows define the behavior for determining whether to retry based on the exception that was raised.

##### Example - basic

Continuing with the `Ping.Send()` method, we can define a policy that will retry when a `PingException` exception is detected.

#!markdown

For example, let's imagine we were consuming an HttpService which occasionally gives us a `429 - Too Many Requests` error in an `HttpServiceException`.

We can implement a policy which will only retry if we receive this exception.

#!csharp

public class RetryOnTooManyRequestsPolicy : IRetryPolicy
{
  public bool CanRetry(Exception exception)
  {
    return (exception is HttpRequestException httpException && httpException.StatusCode.ToString() == "429");
  }
}

#!markdown

#### `AggrregatePolicy`

This gives you a means of combining together multiple policies.

The `AggregatePolicy` only succeeds if *ALL* of its children succeed.

An aggregate following takes the following form:

```csharp
var aggregatePolicy =
  new AggregatePolicy
  {
    Policies =
    {
      new CustomPolicy1(),
      new CustomPolicy2(),
    },
  }
```

##### Example

The example below defines a new custom policy that will retry upon detecting an exception of type `PingException`, and combines it with the `RetryOnTooManyRequestsPolicy` policy to produce an `AggregatePolicy`

#!csharp

public class RetryOnPingExceptionPolicy: IRetryPolicy
{
    public bool CanRetry(Exception exception)
    {
        return exception is PingException;
    }
}

#!csharp

AggregatePolicy aggregatePolicy = new AggregatePolicy()
{
    Policies = 
    {
        new RetryOnPingExceptionPolicy(),
        new RetryOnTooManyRequestsPolicy()
    }
};

Ping pingSender = new Ping();
PingReply reply = Retriable.Retry(() => pingSender.Send("www.endjin.com"), CancellationToken.None, strategy: new Count(10), policy: aggregatePolicy);
