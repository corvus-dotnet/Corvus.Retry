#!markdown

# Corvus.RetryTask - Sample Notebook

#!markdown

First, add a reference to the `Corvus.Retry` NuGet package.

#!csharp

#r "nuget: Corvus.Retry, 1.0.2"

#!markdown

Add a using statement for `Corvus.Retry` namespace and the others we'll be using in this notebook.

#!csharp

using Corvus.Retry;
using Corvus.Retry.Strategies;
using Corvus.Retry.Policies;
using System.Net.NetworkInformation;
using System.Threading;
using System.Net.Http;
using System.Web;
using System.Diagnostics;
using System.Threading;

#!markdown

## `RetryTask`

The `RetryTask` is an analog of [`Task`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-7.0) which has built-in retry semantics.

Instead of calling `Task.Factory.StartNew()` you can call `RetryTask.Factory.StartNew()` with all the familiar parameters.

In addition to those usual parameters, you can pass an `IRetryPolicy` and an `IRetryStrategy` to control the retry behaviour. The defaults are the same as for `Retriable`.

(See the [`RetriableSample` notebook](link) in the repository for examples on `Retriable`, `IRetryPolicy` and `IRetryStrategy`)

### Example

This basic example uses `RetryTask.Factory.StartNew()` just like you could use `Task.Factory.StartNew()`: to execute multiple operations concurrently.

We have a `MockClient` class with a single method, `DoAnOperationWithAPotentialTransientError()`, that fails transiently - it throws a `MockClientException` with 80% probability. There's also a `RetryonMockClientExceptionPolicy`, which is a custom implementation of `IRetryPolicy` that will trigger a retry when a `MockClientException` is detected.

#!csharp

[Serializable]
public class MockClientException: Exception
{

    override public string Message { get; }

    public MockClientException(string message)
    {
        this.Message = message;
    }
}

#!csharp

public static class MockClient
{
    private static Random rand = new Random();

    public static void DoAnOperationWithAPotentialTransientError()
    {   
        Console.WriteLine("method DoAnOperationWithAPotentialTransientError() called");
        Thread.Sleep(500);
        int randomNum = MockClient.rand.Next(1, 11);
        if (randomNum < 9) {throw new MockClientException(message: "Too many requests");}
        Console.WriteLine("Operation succeeded");
    }
}

#!csharp

public class RetryonMockClientExceptionPolicy : IRetryPolicy
{
  public bool CanRetry(Exception exception)
  {
    return (exception is MockClientException mockClientException);
  }
}

#!markdown

Now, let's call `DoAnOperationWithAPotentialTransientError()` three times via `RetryTask.Factory.StartNew()`. We should see the method being retried a number of times.

#!csharp

Task task1 = RetryTask.Factory.StartNew(() => MockClient.DoAnOperationWithAPotentialTransientError(), new Count(5), new RetryonMockClientExceptionPolicy());
Thread.Sleep(200);
Task task2 = RetryTask.Factory.StartNew(() => MockClient.DoAnOperationWithAPotentialTransientError(), new Count(5), new RetryonMockClientExceptionPolicy());
Thread.Sleep(200);
Task task3 = RetryTask.Factory.StartNew(() => MockClient.DoAnOperationWithAPotentialTransientError(), new Count(5), new RetryonMockClientExceptionPolicy());

task1.Wait();
task2.Wait();
task3.Wait();

#!markdown

### Example - mock HTTP service

Let's imagine we were consuming an HttpService which occasionally gives us a `429 - Too Many Requests` error in an `HttpServiceException`.

We may want to make requests asynchronously, so we can do other work whilst they're processing, and have they retry when a `429 - Too Many Requests` exception is detected.

Let's define a `HttpServiceException`, a `MockHttpService`, and a custom retry policy that will trigger a retry when a `429 - Too Many Requests` exception is detected.

#!csharp

[Serializable]
public class MockHttpServiceException: Exception
{

    override public string Message { get; }
    public string StatusCode { get; }

    public MockHttpServiceException(string message, string statusCode)
    {
        this.Message = message;
        this.StatusCode = statusCode;
    }
}

#!csharp

public class MockHttpService
{
    public async Task MakeLotsOfRequestsAsync()
    {
        Console.WriteLine("MakeLotsOfRequests() method called");
        await Task.Delay(1000);
        throw new MockHttpServiceException("429 - Too Many Requests", "429");
    }

    public async void MakeRequestThatWillTimeOutAsync()
    {
        Console.WriteLine("MakeRequestThatWillTimeOut() method called");
        await Task.Delay(1000);
        throw new MockHttpServiceException("408 - Request timed out", "408");
    }
}

#!csharp

public class RetryOnTooManyRequestsPolicy : IRetryPolicy
{
  public bool CanRetry(Exception exception)
  {
    return (exception is MockHttpServiceException httpException && httpException.StatusCode == "429");
  }
}

#!csharp

MockHttpService mockHttpService = new();
//Action retryActionOld = () => Retriable.Retry(() => mockHttpService.MakeLotsOfRequestsAsync(), CancellationToken.None, strategy: new Count(10), policy: RetryOnTooManyRequestsPolicy);
Task retryTask = RetryTask.Factory.StartNew(() => mockHttpService.MakeLotsOfRequestsAsync(), CancellationToken.None, strategy: new Count(10), policy: new RetryOnTooManyRequestsPolicy());
Thread.Sleep(5000); // Wait some time before disabling retry
retryTask.Wait();
